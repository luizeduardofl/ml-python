# -*- coding: utf-8 -*-
"""Atividade_3_16-10-24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UQLaAauRP5y5hryNYxjxeT81MSa64D-G
"""

import pandas as pd

data = pd.read_csv('https://raw.githubusercontent.com/ect-comp/ml/refs/heads/master/dados/heart_disease_uci.csv')

data.head()

data.describe()

X = data.drop('target', axis=1)
y = data['target'].values

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0)

print(f'Tamanho do conjunto de treinamento: {len(X_train)}')
print(f'Tamanho do conjunto de teste: {len(X_test)}')
print(f'Tamanho do conjunto total: {len(X_train + X_test)}')

from keras.models import Sequential
from keras.layers import Dense

# Criando o modelo sequencial
model = Sequential()

# Adicionando a primeira camada escondida com 4 neurônios e função de ativação 'relu'
model.add(Dense(units=4, activation='relu', input_shape=(13,)))

# Adicionando a camada de saída com um neurônio e função de ativação 'sigmoid'
model.add(Dense(units=1, activation='sigmoid'))

# Compilando o modelo com a função de perda 'binary_crossentropy', o otimizador 'adam' e a métrica de acurácia
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# Exibir o sumário do modelo
model.summary()

# Treinando o modelo com os dados de treino e validação por 100 épocas e um tamanho de lote de 13
model.fit(x=X_train, y=y_train, epochs=100, batch_size=13)

import numpy as np

# Avaliando o modelo com os dados de teste
loss, accuracy = model.evaluate(X_test, y_test)

print(f'Acurácia: {accuracy * 100:.2f}%')

# Obtendo as previsões do modelo para os dados de teste
y_pred = model.predict(X_test)

# Obtendo as classes previstas
y_pred_classes = np.argmax(y_pred, axis=1)

# Obtendo as classes verdadeiras
y_true = y_test

# Importando a função da matriz de confusão da sklearn
from sklearn.metrics import confusion_matrix

# Gerando a matriz de confusão
cm = confusion_matrix(y_true, y_pred_classes)

# Imprimindo a matriz de confusão
print(cm)